Применены все 5 принципов SOLID. Вот по одному примеру для каждого с обоснованием:

S (Single Responsibility): Класс Order отвечает только за управление статусом заказа и его товарами, не занимается хранением товаров в магазине или рекомендациями. Обоснование: Это позволяет изменять логику заказов без влияния на другие части системы. Пример: https://github.com/LoginovAlexsandr/Task_Shop/main/src/Order.java (методы updateStatus и returnOrder).
O (Open-Closed): Класс Store закрыт для модификации (его методы фильтрации не меняются), но открыт для расширения (можно добавить новые фильтры через перегрузку методов без изменения существующего кода). Обоснование: Добавление нового типа фильтра (например, по рейтингу) не требует изменения базового filterByPrice. Пример: https://github.com/LoginovAlexsandr/Task_Shop/main/src/Store.java (метод filterByPrice и filterByManufacturer).
L (Liskov Substitution): Класс Order может быть использован вместо любого объекта, реализующего IOrderTracker, без нарушения поведения (например, в Main для трекинга). Обоснование: Подклассы/реализации интерфейса не ослабляют постусловия (все возвращают корректный статус). Пример: https://github.com/LoginovAlexsandr/Task_Shop/main/src/Order.java (реализация getStatus из IOrderTracker).
I (Interface Segregation): Интерфейс IRatingProvider содержит только методы для рейтингов (get/set), не смешивая с другими функциями (например, не включает трекинг). Обоснование: Клиенты (как RatingService) используют только нужные методы, без ненужных зависимостей. Пример: https://github.com/LoginovAlexsandr/Task_Shop/main/src/IRatingProvider.java (интерфейс с методами getRating и setRating).
D (Dependency Inversion): RecommendationService зависит от абстракции IRatingProvider (интерфейса), а не от конкретной реализации (Product). Обоснование: Это позволяет заменить провайдера рейтингов без изменения RecommendationService. Пример: https://github.com/LoginovAlexsandr/Task_Shop/main/src/RecommendationService.java (конструктор принимает IRatingProvider).
